// server.js

// Import Elysia and the CORS plugin
import { Elysia } from 'elysia';
import { cors } from '@elysiajs/cors';
import db from './db-connector.js';
import dotenv from 'dotenv';

dotenv.config({path: '../.env'})

// The 'path' module is not needed for this conversion
// since Elysia's routing handles paths directly.

// --- Security Whitelist ---
// This prevents SQL injection by only allowing known table names.
const ALLOWED_TABLES = new Set([
  'Pets',
  'Contacts',
  'PetRaces',
  'Applications',
  'AppAnswers',
  'AppQuestions',
]);

const PORT = process.env.VITE_BACKEND_PORT || 3000;

const app = new Elysia();

// Use the CORS plugin to handle CORS headers automatically
app.use(cors());

// the following function is AI-generated by Gemini-2.5-pro
/**
 * Converts an ISO 8601 date string to a MySQL DATETIME format string.
 * @param {string} isoString The date string to convert (e.g., '2024-10-12T07:00:00.000Z')
 * @returns {string|null} The formatted string 'YYYY-MM-DD HH:MM:SS' or null if input is invalid.
 */
function toMySQLDateTime(isoString) {
  if (!isoString) return null;

  try {
    const date = new Date(isoString);
    // .toISOString() returns 'YYYY-MM-DDTHH:mm:ss.sssZ'
    // We slice the first 19 characters and replace 'T' with a space.
    return date.toISOString().slice(0, 19).replace('T', ' ');
  } catch (error) {
    console.error("Could not parse date:", isoString, error);
    return null; // Return null for invalid dates
  }
}

app.post('/edit/:table', async ({params, body}) => {
  // console.log('request received')
  const { table } = params;
    // --- Security Check ---
  if (!ALLOWED_TABLES.has(table)) {
    // Elysia's 'set' object handles the status and headers for you
    set.status = 400;
    return { error: 'Invalid table specified.' };
  }
  // console.log('table valid')
  // assume body is fully valid xD
  const { applicationID, approvalState, applicationDate, note, contactID, petID } = body || {};

  if (!applicationID || !approvalState || !applicationDate || !contactID || !petID) {
    set.status = 400
    return { error: "Bad request"}
  }

  const formattedApplicationDate = toMySQLDateTime(applicationDate)

  if (!formattedApplicationDate) {
    set.status = 400;
    return { error: 'Invalid date format.' };
  }

  try {
    // pray for no SQL injection attacks...
    const query = `call sp_update${ table.substring(0, table.length - 1) }ByID(?, ?, ?, ?, ?, ?);`
    console.log('executing ', query)
    // console.log('calling...')
    const values = [applicationID, approvalState, formattedApplicationDate, note ?? null, contactID, petID]
    await db.execute(query, values)
    // await db.execute()
    // console.log('done calling.')
    return { response: 'Successfully updated table.'}
  } catch (error) {
    console.error('Error executing query:', error);
    set.status = 500;
    return { error: 'An error occurred on the server.' };
  } 
})

app.post('/add/:table', async ({body, params, set}) => {
  // console.log('request received')
  const { table } = params;
    // --- Security Check ---
    console.log('table received')
  if (!ALLOWED_TABLES.has(table)) {
    // Elysia's 'set' object handles the status and headers for you
    set.status = 400;
    return { error: 'Invalid table specified.' };
  }
      console.log('parsing data')
      console.log('received', body)

  // console.log('table valid')
  // assume body is fully valid xD
  const { approvalState, applicationDate, note, contactID, petID } = body || {};
      console.log('parsed data')

  if (!approvalState || !applicationDate || !contactID || !petID) {
    set.status = 400
    return { error: "Bad request"}
  }

        console.log('verify data')


  const formattedApplicationDate = toMySQLDateTime(applicationDate)

  if (!formattedApplicationDate) {
    set.status = 400;
    return { error: 'Invalid date format.' };
  }

  try {
    // pray for no SQL injection attacks...
    const query = `call sp_insert${ table.substring(0, table.length - 1) }(?, ?, ?, ?, ?);`
    console.log('executing ', query)
    // console.log('calling...')
    console.log('???', approvalState, formattedApplicationDate, note ?? null, contactID, petID)
    const values = [approvalState, formattedApplicationDate, note ?? null, contactID, petID]
    await db.execute(query, values)
    // await db.execute()
    // console.log('done calling.')
    return { response: 'Successfully updated table.'}
  } catch (error) {
    console.error('Error executing query:', error);
    set.status = 500;
    return { error: 'An error occurred on the server.' };
  }
})

app.put('/delete/:table/:id', async ({params, set}) => {
  const { table, id } = params;

  try {
    const query = `call sp_delete${ table.substring(0, table.length - 1) }ByID(${id});`
    // console.log('calling...')
    await db.query(query)
    // console.log('done calling.')
    return { response: 'Successfully delete.'}
  } catch (error) {
    console.error('Error executing query:', error);
    set.status = 500;
    return { error: 'An error occurred on the server.' };
  }
})

app.put('/reset', async () => {
  try {
    const query = 'call sp_resetAll();'
    // console.log('calling...')
    await db.query(query)
    // console.log('done calling.')
    return { response: 'Successfully reset database.'}
  } catch (error) {
    console.error('Error executing query:', error);
    set.status = 500;
    return { error: 'An error occurred on the server.' };
  }
})

app.get('/:table/description', async ({ params, set }) => {
  const { table } = params;

  // --- Security Check ---
  if (!ALLOWED_TABLES.has(table)) {
    // Elysia's 'set' object handles the status and headers for you
    set.status = 400;
    return { error: 'Invalid table specified.' };
  }

  try {
    const query = `DESCRIBE ${table};`;
    const headers = await db.query(query);
    return headers;
  } catch (error) {
    console.error('Error executing query:', error);
    set.status = 500;
    return { error: 'An error occurred on the server.' };
  }
});

app.get('/:table/contents', async ({ params, set }) => {
  const { table } = params;

  // --- Security Check ---
  if (!ALLOWED_TABLES.has(table)) {
    // Elysia's 'set' object handles the status and headers for you
    set.status = 400;
    return { error: 'Invalid table specified.' };
  }

  try {
    const query = `SELECT * FROM ${table};`;
    const [rows] = await db.query(query);
    return rows;
  } catch (error) {
    console.error('Error executing query:', error);
    set.status = 500;
    return { error: 'An error occurred on the server.' };
  }
});

app.get('/Contacts/friendly', async ({ params, set }) => {
  try {
    const query = `call sp_getJoinedContactsID();`;
    const [rows] = await db.query(query);
    return rows;
  } catch (error) {
    console.error('Error executing query:', error);
    set.status = 500;
    return { error: 'An error occurred on the server.' };
  }
})

app.get('/Pets/friendly', async ({ params, set }) => {
  try {
    const query = `call sp_getJoinedPetsID();`;
    const [rows] = await db.query(query);
    return rows;
  } catch (error) {
    console.error('Error executing query:', error);
    set.status = 500;
    return { error: 'An error occurred on the server.' };
  }
})

app.listen(PORT, () => {
  console.log(`Elysia server started on http://localhost:${PORT}; press Ctrl-C to terminate.`);
});